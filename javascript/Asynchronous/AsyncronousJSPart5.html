<!-- //learn call back function
//DOM questions
async function::
1,4,23
delay in data, or data is coming from outside browser then we use asyncronous
1-callback
2-callbackhell() -> multiple callback functions called settimeout,
3-promise
4-promisses chaining
5-error handling
6-async function
7-event bubling
9: closure: 
10: memorisation 
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div>
      <h1 class="heading1"></h1>
      <h1 class="heading2"></h1>
      <h1 class="heading3"></h1>
      <h1 class="heading4"></h1>
      <h1 class="heading5"></h1>
      <h1 class="heading6"></h1>
      <h1 class="heading7"></h1>
      <h1 class="heading8"></h1>
      <h1 class="heading9"></h1>
      <h1 class="heading10"></h1>
    </div>
  </body>
  <script>
    //callbyhell fucntion, setinterval inside another setinterval function. these are callback function
    ha1 = document.querySelector(".heading1");
    ha2 = document.querySelector(".heading2");
    ha3 = document.querySelector(".heading3");
    ha4 = document.querySelector(".heading4");
    ha5 = document.querySelector(".heading5");
    ha6 = document.querySelector(".heading6");

    //function inside function
    // setInterval(() => {
    //   ha1.textContent = "heading1";
    //   setInterval(() => {
    //     ha2.textContent = "heading 2 interval2";
    //     setInterval(() => {
    //       ha3.textContent = "heading 3 interval3";
    //       setInterval(() => {
    //         ha4.textContent = "heading 4 inteval 4";
    //         setInterval(() => {
    //           ha5.textContent = "heading 5 interval 5";
    //           setInterval(() => {
    //             ha6.textContent = "headign 6 interval 6";
    //             setTimeout(() => {
    //               ha6.append("  -->>  this is call back hell fucntion");
    //             }, 2000);
    //           }, 2000);
    //         }, 2000);
    //       }, 2000);
    //     }, 2000);
    //   }, 2000);
    // }, 2000);

    //Promise
    // > there states: start, pending, complete
    // > resolve,reject
    // > then(condition true) and catch (condition false)

    //-------------PROMISE------------->
    const bucket = ["water", "noodles", "masala", "salt"];

    const friedmaggi = new Promise((resolve, reject) => {
      if (
        bucket.includes("water") &&
        bucket.includes("noodles") &&
        bucket.includes("masala") &&
        bucket.includes("salt")
      ) {
        resolve({ key: "maggi created" });
      } else {
        reject({ key: "moggi not created" });
      }
    });
    friedmaggi
      .then((fridmagi) => {
        //true value
        console.log(fridmagi.key);
      })
      .catch((error) => {
        //false value
        console.log(error.key);
      });

    //-------------PROMISE------------->

    function mypromise() {
      return new Promise((resolve, reject) => {
        resolve("hanumant");
        reject("err");
      });
    }

    mypromise()
      .then((val) => {
        console.log(val);
        val += "tech";
        //return e         #retuen promise value return as a promise not as a value
        return Promise.resolve(val);
      })
      .then((newval) => {
        console.log(newval);
        newval += "world";
        //return Promise.reject(newval);
        return Promise.resolve(newval);
      })
      .then((et) => {
        console.log("in resolve ", et);
      })
      .catch((e) => {
        console.log("in reject" + e);
      });

    //-------------PROMISE CHAINING ------------->
    //promise chaing, use then and use return explicit value return the value by itself
    //we have to mention resolve and reject for then to execute
    //promise chaining is better than callback hell fucntion,fucntion inside function like a DOM is called whereas here, with then

    function textchange(e, text, color, time) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (e) {
            e.textContent = text;
            e.style.color = color;
            resolve();
          } else {
            reject();
          }
        }, time);
      });
    }
    //explicit fucntion no return value
    textchange(ha1, "one", "red", 1000)
      .then(() => textchange(ha2, "two", "yellow", 1000))
      .then(() => textchange(ha3, "three", "blue", 1000))
      .then(() => textchange(ha4, "four", "green", 1000))
      .catch((e) => console.log(e));

    //-------------ERROR HANDLING------------->
    // if user made an error: without try cacth, the server stop and doesnt execute next lines of ConvolverNode
    // if try catch is used, next value is executed without server being stoped
    //finally if errro is there or not there it will execute
    let usr = {
      name: "sakshi",
      city: "lucknow",
    };

    //console.log("without try and catch",usr.address);  the server will stop and not runn next line
    try {
      console.log(usr.address); //undefined, next lines are executed
    } catch (e) {
      console.log(e);
    } finally {
      console.log("finally block");
    }
    console.log("last");
  </script>
</html>
