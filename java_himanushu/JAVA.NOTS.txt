JAVA:
//cmd+shift+o-- for instialling all the packages used in class
#systrace:: SHOTCUT for sopln   printbox with classname
//psvm:: for s=public statci void main
// sysout: enpty printbox

>OBJECT ORIENTED , PLATFORM INDEPENDENT(IT CAN RUN IN ANY PLATFORM VISUALcode,intellige,eciplse NETBEAN,ANY CODE EDITOR)  PROGRAMING LANGUAGE 
>1995 JIMS GARWINS
>COFEE
> NON PRIMITIE: CLASS, ARRAY, ENUM, STRING 
>

// evening 4-6 pm 
-erro handling
> specialiation 
> arry, string

Core Java---
Oct 10: 
package
inferface
polymorism
access modifies
relations
    > referencse
    > is a relation inheritance
    > inner class



innerclass
lambda expression - to increase the performance in projects

array,enum,string
local variable
static -> local and instance varible
Collection frameword: set,List,Queue,stack,LinkedList,PriorityQueue, DoubleEndedQueue(anywhere in line we can push or pop)


WHY PLATFORM INDEPENDENT:
JAVA COMPILER::: CONSERT SRC CODE TO BYTE CODE(.class) and it will check the synaztax and all error at a time and diplay all error at once 
BYTE CODE WILL RUN IN any given platorm
whe

>class firmst name will be capital and we will save file with .java extension

> javac Main.java ---> Main.class(bytecode-> which is not readable)
> java Main.java --> Run(output)
> JDK (java developement Kit- oracle website ), 
>JRE (java run environemtn), JVM(java virtual machine)
> JDK internally hold JRE and JVM and JAVA library
> Java Run time: it create a enviroment whiich is responsible for run the CODE
> jdk is like package,json, which is not readable
> Java virtual machine--> byte code to execute and create redults

> compleier converst src code to byte codeand jvm execute bytecode .class and execute the result

>> Question:
Q; differnece between compileer and interpreter:
    >compile, checks the syntax and show all error at once ( we can complile one time and then use java Main.java) 
    > JAVA COMPILER(transalate all at once)::: CONSERT SRC CODE TO BYTE CODE(.class) and it will check the synaztax and all error at a time and diplay all error at once 

    Interpreator(line by line): javascript: responsible for check the code line by line , erd: 20 lines code
    line 5 error, after 5th linecode will not run and it  iwll throw error


> Java library: collection of predefined functions(packahe,class, interface)
> JVM execute  the byte code and generate the result


Class:::

>Class is a strutured layout in java which is responsible for creating the OBJECT
>collecton of variables, methos,d block of constructor

package: its a collection of classes and interfaces
interfaces are the collection of variable and methods
variabel: public static,default,private
>primitive: character, boolean, number, float, double
> statick  "static c" variable,blck, constrotor can be called/ access by class
> Non statkc "int b" will be access by obj name 
> public stactic(access by class) void(return ) main (string args[](argument passed as parametersx))
> this is starting point of PROGRAM
? java 17 after java 6 we have to use this 

public class Main{
    static int a=10;
    int b=20;

    public static void Main(String args[])
    {
        Main.a;
        Main obj=new Main();
        obj.b();
    }
}

string in double code
character in single code

DOWNLOAD:
arms mac1  dmg file

 check hjava mervion on macbook pro --/usr/libexec/java_home -V

>/Users/sakshisrivastava
> ls -all
>open .zshrc
>export JAVA_HOME=$(/usr/libexec/java_home -v 21.0.4)
>export PATH=$JAVA_HOME/bin:$PATH
>echo $JAVA_HOME
>/Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home

> java -version
> go to hanumant folder 
> touch 


----------------------


Data Types:::

1int= 1bit=8 byte
mobile - 7838125076L

Data type is used for defining the type of data., it is of two types
1) Primitive (single value data format): 
    > Integer (int,long(9 place above),byte,short-create file stream)
    > Float  float(uptill 2-3 points) , double
    > Character char
    > Boolean
2)Non Primitive(multiple value data format):
    -Class
    -ENUM  -enumeration, collection framework as a data type
    -String
    -Interface

Method:
    - method are the actions which execute to generate the result
    <IMPORTANT>
    -they are two type  : STATIC, NON STATIC
    ->> STATIC METHOD ARE THE method which is declared with the static keyword
        static method will be accessible with classname and they will get the memory within the class
    ->>NON-STATIC is acessed by obj of a class and it will take memory space of an OBJECT 
    --> and obj will access both member of the class(static and non static) but it is not advised


    Syntax:
    // parameters are used to transfer data from one method to another method
        ReturnType Methodname ( parameters ) 


Variables(8 byte):

    -are the containers which is used to store the data

    Variables of two types:
        -> Static Variables
        -> Non static variables
    
    >static String name='sakshi';
    >float age=30.345f
    >double age=234.23324d


------------------------------------------------

Object:
    >object are container which hold non statc methods,variables,contructor component of the class.
    > we can create the object with the help of class 
    > Main obj=new Main();



-----------------------------------------------------
> Filename will be Class Name and first letter of class is capital
>
public class Main {
    public static void main(String agrs[]){
        String str="hello world";
        System.out.println(str);
    }
}

concatination
    >System.out.println("a*b="+c);


-----------------------------------------------------
> to run
    > javac Main.java
    > java Main.java

-----------------------------------------------------

SCANNER::
    > Scanner class is used to take the input from the user
    > import java.util.Scanner
    > Scanner sc=new Scanner(System.in)
    > System.in will take the values as input
    > if varibales are defined inside main class, then we have to make a method to display the result.and call that method in main method.
    > if the variables are defined in main method then the output is showed and calculated in the main method only

>if we will take the input as a integer so we willl use .nextInt()
>float ----> .nextFloat()
>long ----> .nextLong()
>for charater and string, whole sentence ----> .nextLine()
> byte(stream) ----> .nextByte()
> short(stream) ----> .nextShort()


-----------------------------------------------------

>> Block: set of staments which is inclosed in curly braces
these are 2 types:
-static block  
-non static block

- static block =---->

static{

}

-non static block--->
{

}

-----------------------------------------------------------------------------------------------------------------------------

Q1-differnece between block and constructor and which has a highest priority
Ans Static, non static , constructor
    - static has most precendence
    - class will be create
    - obj of the class is called, ( same time non static block and constructor will be invoked)
    - non static block
    -constructor
----------------------------------------------------------------------------------------------------

>>> parameters are the variables that transfer data from one method to another method
>>Non parametriesed constructor are the constructore which does not take any argument
>> we have to create method and obj to display the output stored.

> parameters are the variables which are used to transfer data from one method to another
Q:::: to perform the paramertised construcntor we have to use this keyword
>>> this always for parametrised constructor keyword refers to the current class or component and this is used to loading the data into variables
----------------------------------------------------------------------------------------------------


OPERATORES::

operators are used to perform the operations on the object or component.
there are 4 types of operators
    1) Arthematic ::: +,-,/,*,%
    2) Logical ::: &&,||,!
    3) Relational::: <=,>=,>,<,!=
    4) Increment and Decrement::: ++,--

Control Structure::::

    Control Structure are used to control the execution flow of the PROGRAM
    these are three types::
        1) Selections Statement : if,else-if,else nested if-else 
        2) Iterative Statement:: while, dowhile,for
        3) Branching Statement:: swtich,return ,break
    
// in vscode first class  that has psvm among three classes is always consider main class 

int arr[]={1,2,3}; #1D array

Q : if interger input is taken before string input then it skip the string input
Ansert: // int res=Integer.parseInt(sc.nextLine());
        float res=Float.parseFloat(sc.nextLine());


in 1 file, if more than 1 classes are made then, 
    -1st class should be public and has psvm method,    
    -and other two classes insided ame file should not be public

Interface:::
    >the process of interlinking classes using implement keyword
    > it is a collection of abstract method and concrete method
    > abstract method are the method which is declared with abstract keyword , they dont have the method body eg abtract void add(int x,int y);
    > abstract method is defined in abstract class and interfaces only. 
    > abstract method will be called by classes that implement this interface
    > we cannot instantiate interface

    Coding rules of Interface:
Rule-1 : we use "interface" keyword to construct interfaces
syntax:
interface Interface_name
{
//Interface_body
}

Rule-2 : The programming components which are declared within the interface are automatically "public".
Note:
=>The programming components which are declared in classes
without any access modifiers are considered as "default".

Rule-4 : The variables which are declared within the interface are
automatically static and final variables.

Rule-5 : The methods which are declared within the interface are
automatically NonStatic abstract methods.
(static abstract methods are not available)

Rule-6 : Interfaces cannot be instantiated in Java,which means we cannot
create object for Interfaces.

Rule-7 : Interfaces are implemented to classes using "implements" keyword and the classes are known as implementation classes.

Rule-8 : These implementation classes must construct the body for all
abstract methods of Interface.
Package::
    >it is a collection of classes and interfaces
    >it is of two types:
        > Pre defined package (packages which is avaible from java library, java.util,java.lang,jakarta.servlet.http, )
        > User Defined package (created by users )

Access Modifiers:
    which defines the availablity of class or compononet throughout the project
    > public -> accessed throughout the project by creating obj
    > private -> access only within a class
    > protected -> access within the package and outside the package by extend keyword
    > default -> access within the package by creating object
> we can sysout only inside method
> import is to make the classes available to the other classes
> we can call import with packagename.*; for all 
> pacakagename.classname for specific //import p1.AccessModifiers;
> import p1.* or p1.classname and then make the obj of the class and print inside the main mehod or any method obj.name
package p2;
import p1.AccessModifiers;
//import p1.AccessModifiers;
public class AccessModifier2 extend AccessModifier {

	public static void main(String args[]) {
		AccessModifiers obj=new AccessModifiers();	
		System.out.println(obj.name);			
	}
}

// final vaiables are the variables wihich is instalised with value and we cannot modify it at a run time

//Differnce between: 
//	local variable are variable which is declared inside a methood.abstract
//	instance variable are the variable which is written outside of method

Oct 15th::
method overriding
overloading

Oct 16th:
interface
polymorshim
abstract class
encapsulation
innerclass a,b,c->th eavaiblabilty of single call to work with other class
genreation, parent class method and override method of class b
Oct: 17L
specialisation
lambda expression
exception handling
	-check/uncheck
array
string 
Collection framework
	-innerbuf
file-stream
cloning

advance java:
jdbc
servlet
jsp
jstl



------------------------------

Relations:::::

The process of establishing communication between the components are called Relations:
> it is of three type:
    > Reference (has a relation) interlinking objects
    > Inheritance (is a relation) interlinking classes
    > InnerClass 
    
> within same package we dont need to import classes or variible of differnt classes
> to access the resourcess within same package we only need to create obj of differnt class 

------------------------------------------------------------------------------------------------------------------------

Inheritance:::
the process of interlinking class using extend keyword

- is a relation
-single level inheritance 2 classs and main class (parent class inherit its property in one child class)
- multi-level-inheritance 3 or more class and Main class (parent class inherit its properties to mutiple child classes 
- hirarichal inheritance
- 

------------------------------------------------------------------------------------------------------------------------------------------------

-----void is used for printing and it returns nothing
--- whenever we use extend keyword always create the obj of the child

--- package name always start with smaller case
parameters are the values which used to transfer the data from one place to another
OverRiding::
	-Parent-class-method who has same name, same parameters and same return type as of child-class-method,
	 At the time of obj creation of child class, replaced by parent class method will be replaced by child class method.
	-more than one method with same method name in parent class and child class. Parent class method will be replaced by child class at the time of obj creation
OverLoading::
	-More than one method with same name , different parameters and different return type are called and at the time of obj creation java will decide itself what is called on the basis of parameters
	// overloading :more than 1 method with same method-name in same-class but  different parameters is known as POverloading

Overloading with Constructor::
	--interlinking of constructor within same class using this keyword 
	--interlinking id constructor from different class using super keyword
	
-this keyword is used to repent the current class components. it is used to load the data into the variables


-----------------------------------------------------------------------------------------------------------------------------------------------
Interface:::


- interface is the process of interlinking classes using implement keyword
- it is the collection of abstract method and concrete method and variables
- we will declare interface using imterface keyword
- interface class and astract class obj cannot be made
- we can declare abstract method only in interface and abstract class, 
- when we implement interface with abstract method, in class--> we have to make them concrette method
-abstract method does not have any body,but haveing a parameter
- by default interface has public ,abstract static method with no body
- body of the method will be given in the implement class while overloading
-Like abstract classes, interfaces cannot be used to create objects (in the example above, it is not possible to create an "Animal" object in the MyMainClass)
interface rules-->
Interface methods do not have a body - the body is provided by the "implement" class
On implementation of an interface, you must override all of its methods
Interface methods are by default abstract and public
Interface attributes are by default public, static and final
An interface cannot contain a constructor (as it cannot be used to create objects)
Why And When To Use Interfaces?
1) To achieve security - hide certain details and only show the important details of an object (interface).

2) Java does not support "multiple inheritance" (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can implement multiple interfaces. Note: To implement multiple interfaces, separate them with a comma (see example below).


Abstract Method::
	-abstract method is the method which uses abstract keyword and it does not have body
	-concrete method are the method which does not have a abstract keyword and have a body
We will not be able to insitate interface and abstract class
- abstract refers to the idea like love,freedom

----------------------------------------------------------------------------------------------------------------------------------------

Polymorphism---


Many forms
the ability of single programing components to work with multiple programing components is called as Polymorphism or classs
it is of 2 types:
	> Dynamic Polymorphysm
	> Static Paolymorphism

>>Muticlass inheritance causes ambiguity problem so we use interface
> 

--------------------------------------------------------------------------------------------------------------------------------

Abstract class
abstract class is the collection of variables , abstract method, concreete method , block and constructor
abstract does not use interface
we will declare abstract class using abstract keyword and it hold the abstract method
we  cannot declare the object of abstract class

in normal class we cannot have abstract method but in abstract class we can have abstract method
- outerclass cannot be private, innerclass can be private

-------------------------------------------------------------------------------------------------------------------------------------------


Generalisation------


> generalisation is the process in which parent class holding the refernce of child class object
ParentClass obj=(ParentClass) new ChildClass(); // it  takes parnt class all components and only the overidieng method of child
object will hold all the members of parent class and only overide method of child class
> it wil not happen with cabstract classs
> type cast eg--advance class

// it only takes the overiding method of child 


Implicit casting (generalization): Java automatically converts a smaller type (like int) into a larger type (like double), as the larger type can store all possible values of the smaller type. This is a widening process, allowing more general usage.

Explicit casting (specialization): You are manually converting a larger type (like double) into a smaller type (like int). This is a narrowing process, focusing on a smaller, more specific type that may discard or lose some information. Since this conversion may lead to data loss or precision issues, it requires an explicit directive from the programmer.


spclisation ::
the process of constructing child class by taking on feature of parent chils


--------------------------------

innerclass
-the process of declaring class inside another class is called innerclass
-it is of two type:
    >>-member innerclass
        the innerclass which act as a memeber of the other class
        --innerclass cannot have static method
        it if 2 type:
            >>- static member innerclass  
                    - static kkeyword ahead of member innerclass

            >>-non static member innerclass
                 a memeber innerclass which is declared withoud static keyword: it is of two types::
                >>-instance member innerclass
                    -the non static instance member innerclasss which is declared outside the method known instance member innerclas
                    public class ClassOuterCalss{
                        public static void outer1() {
                        System.out.println(outer_x);
                    }        
                    public void outerm2() {
                        System.out.println(outer_x);
                        System.out.println(outer_y);
                    }
                        private class classInnerclass{
                                public static void innerm1() {
                                    System.out.println(x);     
                                }   
                                public void innerm2() {
                                    System.out.println(x);
                                    System.out.println(y);
                                }
                        }
                    public static void main(String[] args) {
                        // TODO Auto-generated method stub
                        InstanceMemberInnerClassMain objoutter=new InstanceMemberInnerClassMain();
                        InstanceMemberInnerClassMain.InnerClass objinner=objoutter.new InnerClass();
                        
                        //		//rules:::
                        //			1) objoutter will have access to only outer class component
                        //			2) objinner  will have access to only inner class component
                        //			3) static members of innerclass can access to static memeber of the outer class
                        //			4) non static memeber of the innerclass can access to non static memeber of the  inner class

                    	}

                    }
                  
                >>-local member innerclass
                    - instide the method we will create the object
                    -the innerclass which is declared inside the method

                    public class ClassInsideMethod {
                            int x=10;
                            public void getdata() {
                                class InnerClass{
                                    public void displayx() {
                                        System.out.println(x);                                       
                                    }                                    
                                }                                
                                InnerClass innerobj =new InnerClass();
                                innerobj.displayx();
                            }                            
                            public static void main(String args[]) {
                                ClassInsideMethod outerobj=new ClassInsideMethod();
                                outerobj.getdata();
                            }

                        }
    >>-anonymous innerclass
        >>- anonymous as class extention
        >>-anonymous as implementation class

-outer class cannot be static and it is only public
-inner class can be static and private,protected and public
---------------- ;
nonstatic member innerclass: a memeber innerclass which is declared withoud static keyword:
it is of two types::

vcariable is static and nonstatic- 2 types::::local and instance 

In Java, an inner class is a class that is defined inside another class. An inner class can access the members of the outer class, including private members, and it can be used to implement callbacks and event handlers. There are four types of inner classes in Java:

>Member Inner Class: It is a non-static class that is defined at the member level of a class. It has access to all the members of the outer class, including private members.

>Local Inner Class: It is a class that is defined inside a method or a block of code. It has access to the final variables of the method or block in which it is defined.

>Anonymous Inner Class: It is a class that is defined inline and has no name. It is used to implement interfaces or extend classes without creating a separate class.

>Static Nested Class: It is a static class that is defined inside another class. It does not have access to the non-static members of the outer class.

Inner classes have several advantages:

Encapsulation: Inner classes can be used to encapsulate implementation details of a class, making the code more modular and maintainable.

Access Control: Inner classes can access private members of the outer class, allowing for more precise control over the visibility of members.

Callbacks and Event Handlers: Inner classes can be used to implement callbacks and event handlers, making it easier to handle events in graphical user interfaces.

Code Organization: Inner classes can be used to organize code by grouping related classes together.

-------------------------------
Instance member innerclass:
Outerclassname.innerclassname obj=outerclassobjname.innerclassname
//rules:::
//			1) objoutter will have access to only outer class component
//			2) objinner  will have access to only inner class component
//			3) static members of innerclass can access to static memeber of the outer class
//			4) non static memeber of the innerclass can access to non static memeber of the  inner class
-------------------------------
local memeber inner classs
    - the class which is decalred inside a method
    - the obj of the innerclass will be created inside the method

anonomous innerclass::
a innerclass which does not have a class name
it is of two types::
    1) Annonomous as Class extention
        > we perform using classx

        Class ClasName{
            public static void m1(int a){
                System.out.println(90);
            }

            public  String m2(String n){
                return "class";
            }
        }

        Class Main{
            ClassName obj=new ClassName(){

                // error static method cannot be overrider
                //public static void m1(int a){
                //    System.out.println(a);
                //}
                public  String m2(String n){
                    return n;
                }
            }

            //obj.m1(10);--> error
            obj.m2("sakshi");
        }
    2) Annomous as implementation class
        > we perform using interface
        > the process of declaring the implementation class without name is known as  Annomous as implementation class
        > we do interface implementation for eg: 
            InterfaceName{
                public abstract void display(int x);

            }
            InterfaceName interface_obj=new InterfaceName(){
                public void display(int x) {
					System.out.println(x);
            };
            interface_obj.display(10);
            }
            }
----------------------------

----------------------------------------------------------------------------------------------------------------------------------------------
if (value.equals("greater")) {}

lambda expression :
- the process of declaring method without its name is called as lambda function
- it is also known as anymonous method and it works only with  one abstract method of interface 

Functionalinterface: a interface with only one abstract method

Factory Method::
- the proces sof constructing object by hiding the object creation process is called as Factory Method

@FunctionalInterface
public interface Interface1 {
	public abstract void m1(int x,int y);
    //	public abstract void m2(int y); lambda expression only need one abstract method in inter interface knowsn as functional interface
	// for more than one abstreact method in interface we can use anonymous function
	public static String m2(String name) {
		return name;
	}
	public static void main(String args[]) {
		//lambda-expession
		// factory method: the process of constructing method by hiding object creation method
//		Interface1 obj= (x)->{
//			System.out.println(2*x);
//			
//		};
//		obj.m1(10);
		Interface1 obj=(x,y)-> System.out.println(2*x*y);
		obj.m1(3, 1);
	}
}
lambda expression also do implementation of factory class
----------------------------------------------------------------------------------------------------------------------------------------------

Exception Handling:: it is the process which is used to handle the exception . It is of two types:
    > Unchecked Exception
        - the exception which is not identified at compile time is called as unchecked Exception
    > Checked Exception
        - the exception which is identified at compile time is called as checked Exception
     To handle exception we use try,catch,finally


Exception: whenever an error occur, server stops ,so that the server will keep on running
    
try{

}catch(e){

}
